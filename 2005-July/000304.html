<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [fetchmail-devel] Cleanups
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/fetchmail-devel/2005-July/index.html" >
   <LINK REL="made" HREF="mailto:fetchmail-devel%40lists.berlios.de?Subject=Re%3A%20%5Bfetchmail-devel%5D%20Cleanups&In-Reply-To=%3C20050703154856.GE2815%40amilo.ms.mff.cuni.cz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000308.html">
   <LINK REL="Next"  HREF="000305.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[fetchmail-devel] Cleanups</H1>
    <B>Miloslav Trmac</B> 
    <A HREF="mailto:fetchmail-devel%40lists.berlios.de?Subject=Re%3A%20%5Bfetchmail-devel%5D%20Cleanups&In-Reply-To=%3C20050703154856.GE2815%40amilo.ms.mff.cuni.cz%3E"
       TITLE="[fetchmail-devel] Cleanups">mitr at redhat.com
       </A><BR>
    <I>Sun Jul  3 17:48:56 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000308.html">[fetchmail-devel] i18n fixes
</A></li>
        <LI>Next message: <A HREF="000305.html">[fetchmail-devel] Cleanups
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#304">[ date ]</a>
              <a href="thread.html#304">[ thread ]</a>
              <a href="subject.html#304">[ subject ]</a>
              <a href="author.html#304">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,
To keep the tradition of destabilizing changes appearing as soon as
a freeze is called for, here are a few cleanups.

fetchmail-6.2.6.alpha1-conf.patch is uncontroversial, I hope:
it removes checks and definitions that the code doesn't use from configure.ac.


fetchmail-6.2.6.alpha1-warn.patch is large, therefore hard to review
and somewhat risky: it modifies the code to avoid all warnings
from gcc-4.0 with -W -Wall.

Most of the changes are cosmetics, making the code more explicit,
but the reply_hack () prototype change is a real bug fix: the
code was using (int *) to point to a size_t, which can lead to
unexpected behavior on 64-bit machines.

The largest part of the patch adds explicit casts between
(char *) and (unsigned char *); the C standard requires an explicit
cast for these conversions, although gcc currently accepts them.
Note that adding the casts like this is mostly a work-around; the
code should probably standardize on one kind of character pointers
(my vote would be (char *) to be consistent with string literals
and &lt;string.h&gt;) - but changing the pointer type requires a very
careful review of the affected code.

Other changes include removing unused parameters and variables
(or silencing the warning if the parameters are a part of the driver
interface and are used in other transports), adding casts to make
comparisons of signed and unsigned types eplicit.

Except for the reply_hack() change above, I'm not sure this patch
should go in before the freeze.  Anyway, I think it is better
to send it and see it rejected than to just delete it.

Eventually I'd like to clean up the code to assume an ISO C-90
compliant compiler (STDC_HEADERS, HAVE_STDARG_H, ...), but those
changes can really wait after the release.
	Mirek
-------------- next part --------------
diff -ur fetchmail-6.2.6.alpha1/configure.ac fetchmail-6.2.6.alpha1.conf/configure.ac
--- fetchmail-6.2.6.alpha1/configure.ac	2005-07-02 14:06:48.000000000 +0200
+++ fetchmail-6.2.6.alpha1.conf/configure.ac	2005-07-03 04:20:15.000000000 +0200
@@ -28,8 +28,8 @@
 AC_TYPE_SIGNAL
 AC_CHECK_HEADERS([unistd.h termios.h termio.h sgtty.h stdarg.h \
 	alloca.h sys/itimer.h fcntl.h sys/fcntl.h memory.h sys/wait.h \
-	sys/shm.h arpa/inet.h arpa/nameser.h netinet/in.h net/socket.h \
-	sys/select.h sys/time.h langinfo.h sys/utsname.h])
+	arpa/inet.h arpa/nameser.h netinet/in.h net/socket.h \
+	sys/select.h sys/time.h langinfo.h])
 AC_CHECK_HEADERS([resolv.h],,,[
 #include &lt;sys/types.h&gt;
 #ifdef HAVE_NETINET_IN_H
@@ -103,11 +103,11 @@
 
 AC_REPLACE_FUNCS([strstr strcasecmp memmove stpcpy])
 
-AC_CHECK_FUNC(MD5Init, AC_DEFINE(HAVE_MD5,1,Define if you have md5 in libc),
+AC_CHECK_FUNC(MD5Init, [],
 	      [AC_LIBSOURCE(md5c.c)
                EXTRAOBJ=&quot;$EXTRAOBJ md5c.\$(OBJEXT)&quot;])
 
-AC_CHECK_FUNC(getopt_long, AC_DEFINE(HAVE_GETOPT_LONG),
+AC_CHECK_FUNC(getopt_long, [],
               [AC_LIBSOURCES([getopt.c, getopt1.c])
 	       EXTRAOBJ=&quot;$EXTRAOBJ getopt.\$(OBJEXT) getopt1.\$(OBJEXT)&quot;])
 
@@ -120,10 +120,10 @@
 AC_SUBST(EXTRAOBJ)
 
 AC_CHECK_FUNCS(tcsetattr stty setsid geteuid seteuid gethostbyname \
-  res_search herror strrchr strerror setlinebuf syslog \
+  res_search strerror syslog \
   snprintf vprintf vsnprintf vsyslog \
   atexit inet_aton strftime setrlimit socketpair sigprocmask sigaction \
-  getopt_long strdup)
+  strdup)
 
 # Under Red Hat 4.0 (and many other Linuxes) -lresolv is seriously flaky
 # and breaks gethostbyname(2).  It's better to use the bind stuff in the C
-------------- next part --------------
diff -ur fetchmail-6.2.6.alpha1.warn/conf.c fetchmail-6.2.6.alpha1/conf.c
--- fetchmail-6.2.6.alpha1.warn/conf.c	2005-02-27 21:19:35.000000000 +0100
+++ fetchmail-6.2.6.alpha1/conf.c	2005-07-02 23:25:53.000000000 +0200
@@ -103,7 +103,7 @@
 	for (idp = list; idp; idp = idp-&gt;next)
 	    if (idp-&gt;id)
 	    {
-		fprintf(stdout, &quot;\&quot;%s\&quot;&quot;, visbuf(idp-&gt;id));
+		fprintf(stdout, &quot;\&quot;%s\&quot;&quot;, visbuf((char *)idp-&gt;id));
 		if (idp-&gt;next)
 		    fputs(&quot;, &quot;, stdout);
 	    }
@@ -335,10 +335,10 @@
 	{
 	    char	namebuf[USERNAMELEN + 1];
 
-	    strncpy(namebuf, visbuf(idp-&gt;id), USERNAMELEN);
+	    strncpy(namebuf, visbuf((char *)idp-&gt;id), USERNAMELEN);
 	    namebuf[USERNAMELEN] = '\0';
 	    if (idp-&gt;val.id2)
-		fprintf(stdout, &quot;(\&quot;%s\&quot;, %s)&quot;, namebuf, visbuf(idp-&gt;val.id2));
+		fprintf(stdout, &quot;(\&quot;%s\&quot;, %s)&quot;, namebuf, visbuf((char *)idp-&gt;val.id2));
 	    else
 		fprintf(stdout, &quot;\&quot;%s\&quot;&quot;, namebuf);
 	    if (idp-&gt;next)
diff -ur fetchmail-6.2.6.alpha1.warn/cram.c fetchmail-6.2.6.alpha1/cram.c
--- fetchmail-6.2.6.alpha1.warn/cram.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/cram.c	2005-07-02 23:09:27.000000000 +0200
@@ -81,20 +81,20 @@
      * [RFC822] as described in [POP3].
      */
 
-    if ((result = gen_recv (sock, buf1, sizeof (buf1)))) {
+    if ((result = gen_recv (sock, (char *)buf1, sizeof (buf1)))) {
 	return result;
     }
 
     /* caller may specify a response prefix we should strip if present */
     respdata = buf1;
-    if (strip &amp;&amp; strncmp(buf1, strip, strlen(strip)) == 0)
+    if (strip &amp;&amp; strncmp((char *)buf1, strip, strlen(strip)) == 0)
 	respdata += strlen(strip);
-    len = from64tobits (msg_id, respdata, sizeof(msg_id));
+    len = from64tobits ((char *)msg_id, (char *)respdata, sizeof(msg_id));
 
     if (len &lt; 0) {
 	report (stderr, GT_(&quot;could not decode BASE64 challenge\n&quot;));
 	return PS_AUTHFAIL;
-    } else if (len &lt; sizeof (msg_id)) {
+    } else if ((size_t)len &lt; sizeof (msg_id)) {
         msg_id[len] = 0;
     } else {
         msg_id[sizeof (msg_id)-1] = 0;
@@ -110,11 +110,11 @@
      * (including angle-brackets).
      */
 
-    hmac_md5(ctl-&gt;password, strlen(ctl-&gt;password),
-              msg_id, strlen (msg_id),
+    hmac_md5((unsigned char *)ctl-&gt;password, strlen(ctl-&gt;password),
+	     msg_id, strlen ((char *)msg_id),
               response, sizeof (response));
 
-    snprintf (reply, sizeof(reply),
+    snprintf ((char *)reply, sizeof(reply),
               &quot;%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x&quot;, 
               ctl-&gt;remotename,
               response[0], response[1], response[2], response[3],
@@ -122,12 +122,12 @@
               response[8], response[9], response[10], response[11],
               response[12], response[13], response[14], response[15]);
 
-    to64frombits (buf1, reply, strlen(reply));
+    to64frombits (buf1, reply, strlen((char *)reply));
 
     /* ship the authentication back, accept the server's responses */
     /* PMDF5.2 IMAP has a bug that requires this to be a single write */
     suppress_tags = TRUE;
-    result = gen_transact(sock, buf1, sizeof(buf1));
+    result = gen_transact(sock, (char *)buf1, sizeof(buf1));
     suppress_tags = FALSE;
     if (result)
 	return(result);
diff -ur fetchmail-6.2.6.alpha1.warn/daemon.c fetchmail-6.2.6.alpha1/daemon.c
--- fetchmail-6.2.6.alpha1.warn/daemon.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/daemon.c	2005-07-02 22:35:41.000000000 +0200
@@ -79,9 +79,10 @@
     wait(&amp;status);
 #endif
     lastsig = SIGCHLD;
+    (void)sig;
 }
 
-RETSIGTYPE null_signal_handler(int sig) { }
+RETSIGTYPE null_signal_handler(int sig) { (void)sig; }
 
 SIGHANDLERTYPE set_signal_handler(int sig, SIGHANDLERTYPE handler)
 /* 
@@ -132,7 +133,7 @@
 }
 
 int
-daemonize (const char *logfile, void (*termhook)(int))
+daemonize (const char *logfile)
 /* detach from control TTY, become process group leader, catch SIGCHLD */
 {
   int fd;
diff -ur fetchmail-6.2.6.alpha1.warn/driver.c fetchmail-6.2.6.alpha1/driver.c
--- fetchmail-6.2.6.alpha1.warn/driver.c	2005-07-02 21:56:55.000000000 +0200
+++ fetchmail-6.2.6.alpha1/driver.c	2005-07-02 22:59:20.000000000 +0200
@@ -105,6 +105,7 @@
 static RETSIGTYPE timeout_handler (int signal)
 /* handle SIGALRM signal indicating a server timeout */
 {
+    (void)signal;
     if(stage != STAGE_IDLE) {
 	timeoutcount++;
 	longjmp(restart, THROW_TIMEOUT);
@@ -115,6 +116,7 @@
 static RETSIGTYPE sigpipe_handler (int signal)
 /* handle SIGPIPE signal indicating a broken stream socket */
 {
+    (void)signal;
     longjmp(restart, THROW_SIGPIPE);
 }
 
@@ -140,7 +142,6 @@
 char *canonical;	/* server name */
 char *principal;
 {
-    char * host_primary;
     KTEXT ticket;
     MSG_DAT msg_data;
     CREDENTIALS cred;
@@ -213,19 +214,19 @@
     krb5_init_context(&amp;context);
     krb5_auth_con_init(context, &amp;auth_context);
 
-    if (retval = krb5_cc_default(context, &amp;ccdef)) {
+    if ((retval = krb5_cc_default(context, &amp;ccdef)) != 0) {
         report(stderr, &quot;krb5_cc_default: %s\n&quot;, error_message(retval));
         return(PS_ERROR);
     }
 
-    if (retval = krb5_cc_get_principal(context, ccdef, &amp;client)) {
+    if ((retval = krb5_cc_get_principal(context, ccdef, &amp;client)) != 0) {
         report(stderr, &quot;krb5_cc_get_principal: %s\n&quot;, error_message(retval));
         return(PS_ERROR);
     }
 
-    if (retval = krb5_sname_to_principal(context, canonical, &quot;pop&quot;,
+    if ((retval = krb5_sname_to_principal(context, canonical, &quot;pop&quot;,
            KRB5_NT_UNKNOWN,
-           &amp;server)) {
+           &amp;server)) != 0) {
         report(stderr, &quot;krb5_sname_to_principal: %s\n&quot;, error_message(retval));
         return(PS_ERROR);
     }
@@ -330,7 +331,7 @@
      * but it's not a disaster, either, since the skipped mail will not
      * be deleted.
      */
-    if (open_warning_by_mail(ctl, (struct msgblk *)NULL))
+    if (open_warning_by_mail(ctl))
 	return;
     stuff_warning(iana_charset, ctl,
 	   GT_(&quot;Subject: Fetchmail oversized-messages warning&quot;));
@@ -352,7 +353,7 @@
 	if (current-&gt;val.status.num == 0 &amp;&amp; current-&gt;val.status.mark)
 	{
 	    nbr = current-&gt;val.status.mark;
-	    size = atoi(current-&gt;id);
+	    size = atoi((char *)current-&gt;id);
 	    stuff_warning(NULL, ctl,
 		    GT_(&quot;  %d msg %d octets long skipped by fetchmail.&quot;),
 		    nbr, size);
@@ -369,7 +370,7 @@
     close_warning_by_mail(ctl, (struct msgblk *)NULL);
 }
 
-static void mark_oversized(struct query *ctl, int num, int size)
+static void mark_oversized(struct query *ctl, int size)
 /* mark a message oversized */
 {
     struct idlist *current=NULL, *tmp=NULL;
@@ -398,7 +399,7 @@
     {
 	for ( ; current; current = current-&gt;next)
 	{
-	    if (strcmp(current-&gt;id, sizestr) == 0)
+	    if (strcmp((char *)current-&gt;id, sizestr) == 0)
 	    {
 		current-&gt;val.status.mark++;
 		break;
@@ -539,7 +540,7 @@
 	{
 	    if ((msgcode == MSGLEN_TOOLARGE) &amp;&amp; !check_only)
 	    {
-		mark_oversized(ctl, num, msgsize);
+		mark_oversized(ctl, msgsize);
 		suppress_delete = TRUE;
 	    }
 	    if (outlevel &gt; O_SILENT)
@@ -902,8 +903,7 @@
 	     * Don't do this if the connection can idle, though; idle
 	     * timeouts just mean the frequency of mail is low.
 	     */
-	    if (timeoutcount &gt; MAX_TIMEOUTS 
-		&amp;&amp; !open_warning_by_mail(ctl, (struct msgblk *)NULL))
+	    if (timeoutcount &gt; MAX_TIMEOUTS &amp;&amp; !open_warning_by_mail(ctl))
 	    {
 		stuff_warning(iana_charset, ctl,
 			      GT_(&quot;Subject: fetchmail sees repeated timeouts&quot;));
@@ -1050,8 +1050,8 @@
 	if ((mailserver_socket = SockOpen(realhost, port, NULL, ctl-&gt;server.plugin)) == -1)
 #endif /* INET6_ENABLE */
 	{
-	    char	errbuf[BUFSIZ];
 #ifndef INET6_ENABLE
+	    char	errbuf[BUFSIZ];
 	    int err_no = errno;
 #ifdef HAVE_RES_SEARCH
 	    if (err_no != 0 &amp;&amp; h_errno != 0)
@@ -1097,7 +1097,7 @@
 		 * where your SLIP or PPP link is down...
 		 */
 		/* warn the system administrator */
-		if (open_warning_by_mail(ctl, (struct msgblk *)NULL) == 0)
+		if (open_warning_by_mail(ctl) == 0)
 		{
 		    stuff_warning(iana_charset, ctl,
 			 GT_(&quot;Subject: Fetchmail unreachable-server warning.&quot;));
@@ -1211,7 +1211,7 @@
 			&amp;&amp; !ctl-&gt;wehavesentauthnote
 			&amp;&amp; ((ctl-&gt;wehaveauthed &amp;&amp; ++ctl-&gt;authfailcount &gt;= 10)
 			    || (!ctl-&gt;wehaveauthed &amp;&amp; ++ctl-&gt;authfailcount &gt;= 3))
-			&amp;&amp; !open_warning_by_mail(ctl, (struct msgblk *)NULL))
+			&amp;&amp; !open_warning_by_mail(ctl))
 		    {
 			ctl-&gt;wehavesentauthnote = 1;
 			stuff_warning(iana_charset, ctl,
@@ -1285,7 +1285,7 @@
 			   GT_(&quot;Authorization OK on %s@%s\n&quot;),
 			   ctl-&gt;remotename,
 			   ctl-&gt;server.truename);
-		    if (!open_warning_by_mail(ctl, (struct msgblk *)NULL))
+		    if (!open_warning_by_mail(ctl))
 		    {
 			stuff_warning(iana_charset, ctl,
 			      GT_(&quot;Subject: fetchmail authentication OK on %s@%s&quot;), 
@@ -1334,7 +1334,7 @@
 
 		/* compute # of messages and number of new messages waiting */
 		stage = STAGE_GETRANGE;
-		err = (ctl-&gt;server.base_protocol-&gt;getrange)(mailserver_socket, ctl, idp-&gt;id, &amp;count, &amp;new, &amp;bytes);
+		err = (ctl-&gt;server.base_protocol-&gt;getrange)(mailserver_socket, ctl, (char *)idp-&gt;id, &amp;count, &amp;new, &amp;bytes);
 		if (err != 0)
 		    goto cleanUp;
 
@@ -1403,7 +1403,7 @@
 		     * count, and allocate a malloc area that would overlap
 		     * a portion of the stack.
 		     */
-		    if (count &gt; INT_MAX/sizeof(int))
+		    if (count &gt; INT_MAX/(int)sizeof(int))
 		    {
 			report(stderr, GT_(&quot;bogus message count!&quot;));
 			return(PS_PROTOCOL);
diff -ur fetchmail-6.2.6.alpha1.warn/env.c fetchmail-6.2.6.alpha1/env.c
--- fetchmail-6.2.6.alpha1.warn/env.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/env.c	2005-07-02 22:32:28.000000000 +0200
@@ -32,7 +32,7 @@
 
 extern char *getenv(const char *);	/* needed on sysV68 R3V7.1. */
 
-void envquery(int argc, char **argv)
+void envquery(char **argv)
 /* set up basic stuff from the environment (including the rc file name) */
 {
     struct passwd by_name, by_uid, *pwp;
diff -ur fetchmail-6.2.6.alpha1.warn/etrn.c fetchmail-6.2.6.alpha1/etrn.c
--- fetchmail-6.2.6.alpha1.warn/etrn.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/etrn.c	2005-07-02 22:28:19.000000000 +0200
@@ -25,6 +25,7 @@
 {
     int ok;
 
+    (void)argbuf;
     ok = SMTP_ok(sock);
     if (ok == SM_UNRECOVERABLE)
 	return(PS_PROTOCOL);
@@ -40,6 +41,7 @@
     char buf [MSGBUFSIZE+1];
     struct idlist *qnp;		/* pointer to Q names */
 
+    (void)id;
     if ((ok = SMTP_ehlo(sock, fetchmailhost, 
 			ctl-&gt;server.esmtp_name, ctl-&gt;server.esmtp_password,
 			&amp;opts)))
@@ -116,6 +118,7 @@
 static int etrn_logout(int sock, struct query *ctl)
 /* send logout command */
 {
+    (void)ctl;
     return(gen_transact(sock, &quot;QUIT&quot;));
 }
 
diff -ur fetchmail-6.2.6.alpha1.warn/fetchmail.c fetchmail-6.2.6.alpha1/fetchmail.c
--- fetchmail-6.2.6.alpha1.warn/fetchmail.c	2005-04-27 20:47:13.000000000 +0200
+++ fetchmail-6.2.6.alpha1/fetchmail.c	2005-07-03 00:34:48.000000000 +0200
@@ -144,7 +144,7 @@
     dropprivs();
 #endif
 
-    envquery(argc, argv);
+    envquery(argv);
 #ifdef ENABLE_NLS
     setlocale (LC_ALL, &quot;&quot;);
     bindtextdomain(PACKAGE, LOCALEDIR);
@@ -506,7 +506,7 @@
     if (run.poll_interval)
     {
 	if (!nodetach)
-	    daemonize(run.logfile, terminate_run);
+	    daemonize(run.logfile);
 	report(stdout, GT_(&quot;starting fetchmail %s daemon \n&quot;), VERSION);
 
 	/*
@@ -938,7 +938,7 @@
     /* get the location of rcfile */
     rcfiledir[0] = 0;
     p = strrchr (rcfile, '/');
-    if (p &amp;&amp; (p - rcfile) &lt; sizeof (rcfiledir)) {
+    if (p &amp;&amp; (size_t)(p - rcfile) &lt; sizeof (rcfiledir)) {
 	*p = 0;			/* replace '/' by '0' */
 	strcpy (rcfiledir, rcfile);
 	*p = '/';		/* restore '/' */
@@ -1355,7 +1355,8 @@
 static int query_host(struct query *ctl)
 /* perform fetch transaction with single host */
 {
-    int i, st = 0;
+    size_t i;
+    int st = 0;
 
     /*
      * If we're syslogging the progress messages are automatically timestamped.
@@ -1543,7 +1544,7 @@
 	if (ctl-&gt;server.service)
 	    printf(GT_(&quot; (using service %s)&quot;), ctl-&gt;server.service);
 	if (ctl-&gt;server.netsec)
-	    printf(GT_(&quot; (using network security options %s)&quot;), ctl-&gt;server.netsec);
+	  printf(GT_(&quot; (using network security options %s)&quot;), (char *)ctl-&gt;server.netsec);
 #else /* INET6_ENABLE */
 	if (ctl-&gt;server.port)
 	    printf(GT_(&quot; (using port %d)&quot;), ctl-&gt;server.port);
diff -ur fetchmail-6.2.6.alpha1.warn/fetchmail.h fetchmail-6.2.6.alpha1/fetchmail.h
--- fetchmail-6.2.6.alpha1.warn/fetchmail.h	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/fetchmail.h	2005-07-02 22:58:44.000000000 +0200
@@ -394,7 +394,7 @@
 extern struct query cmd_opts, *querylist;
 
 /* what's returned by envquery */
-extern void envquery(int, char **);
+extern void envquery(char **);
 
 /* controls the detail level of status/progress messages written to stderr */
 extern int outlevel;    	/* see the O_.* constants above */
@@ -531,7 +531,7 @@
 int open_sink(struct query*, struct msgblk *, int*, int*);
 void release_sink(struct query *);
 int close_sink(struct query *, struct msgblk *, flag);
-int open_warning_by_mail(struct query *, struct msgblk *);
+int open_warning_by_mail(struct query *);
 #if defined(HAVE_STDARG_H)
 void stuff_warning(const char *, struct query *, const char *, ... )
     __attribute__ ((format (printf, 3, 4)))
@@ -542,7 +542,7 @@
 void close_warning_by_mail(struct query *, struct msgblk *);
 
 /* rfc822.c: RFC822 header parsing */
-unsigned char *reply_hack(unsigned char *, const unsigned char *, int *);
+unsigned char *reply_hack(unsigned char *, const unsigned char *, size_t *);
 unsigned char *nxtaddr(const unsigned char *);
 
 /* uid.c: UID support */
@@ -648,7 +648,7 @@
 void deal_with_sigchld(void);
 RETSIGTYPE null_signal_handler(int sig);
 SIGHANDLERTYPE set_signal_handler(int sig, SIGHANDLERTYPE handler);
-int daemonize(const char *, void (*)(int));
+int daemonize(const char *);
 char *fm_getpassword(char *);
 void escapes(const char *, char *);
 char *visbuf(const char *);
diff -ur fetchmail-6.2.6.alpha1.warn/gssapi.c fetchmail-6.2.6.alpha1/gssapi.c
--- fetchmail-6.2.6.alpha1.warn/gssapi.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/gssapi.c	2005-07-02 23:15:28.000000000 +0200
@@ -69,7 +69,7 @@
     else if (outlevel &gt;= O_DEBUG) {
         maj_stat = gss_display_name(&amp;min_stat, target_name, &amp;request_buf,
             &amp;mech_name);
-        report(stderr, GT_(&quot;Using service name [%s]\n&quot;),request_buf.value);
+        report(stderr, GT_(&quot;Using service name [%s]\n&quot;),(char *)request_buf.value);
         maj_stat = gss_release_buffer(&amp;min_stat, &amp;request_buf);
     }
 
@@ -77,7 +77,7 @@
 
     /* upon receipt of the GSSAPI authentication request, server returns
      * null data ready response. */
-    if (result = gen_recv(sock, buf1, sizeof buf1)) {
+    if ((result = gen_recv(sock, buf1, sizeof buf1) != 0)) {
         return result;
     }
 
@@ -107,11 +107,11 @@
             gss_release_name(&amp;min_stat, &amp;target_name);
             /* wake up server and await NO response */
             SockWrite(sock, &quot;\r\n&quot;, 2);
-            if (result = gen_recv(sock, buf1, sizeof buf1))
+            if ((result = gen_recv(sock, buf1, sizeof buf1)) != 0)
                 return result;
             return PS_AUTHFAIL;
         }
-        to64frombits(buf1, send_token.value, send_token.length);
+        to64frombits((unsigned char *)buf1, send_token.value, send_token.length);
         gss_release_buffer(&amp;min_stat, &amp;send_token);
 
 	suppress_tags = TRUE;
@@ -119,12 +119,12 @@
 	suppress_tags = FALSE;
 
         if (maj_stat == GSS_S_CONTINUE_NEEDED) {
-	    if (result = gen_recv(sock, buf1, sizeof buf1)) {
+	    if ((result = gen_recv(sock, buf1, sizeof buf1)) != 0) {
 	        gss_release_name(&amp;min_stat, &amp;target_name);
 	        return result;
 	    }
 	    request_buf.length = from64tobits(buf2, buf1 + 2, sizeof(buf2));
-	    if (request_buf.length == -1)	/* in case of bad data */
+	    if (request_buf.length == -1U)	/* in case of bad data */
 		request_buf.length = 0;
 	    request_buf.value = buf2;
 	    sec_token = &amp;request_buf;
@@ -134,11 +134,11 @@
     gss_release_name(&amp;min_stat, &amp;target_name);
 
     /* get security flags and buffer size */
-    if (result = gen_recv(sock, buf1, sizeof buf1))
+    if ((result = gen_recv(sock, buf1, sizeof buf1)) != 0)
         return result;
 
     request_buf.length = from64tobits(buf2, buf1 + 2, sizeof(buf2));
-    if (request_buf.length == -1)	/* in case of bad data */
+    if (request_buf.length == -1U)	/* in case of bad data */
 	request_buf.length = 0;
     request_buf.value = buf2;
 
@@ -183,7 +183,7 @@
         report(stderr, GT_(&quot;Error creating security level request\n&quot;));
         return PS_AUTHFAIL;
     }
-    to64frombits(buf1, send_token.value, send_token.length);
+    to64frombits((unsigned char *)buf1, send_token.value, send_token.length);
 
     suppress_tags = TRUE;
     result = gen_transact(sock, buf1, strlen(buf1));
diff -ur fetchmail-6.2.6.alpha1.warn/checkalias.c fetchmail-6.2.6.alpha1/checkalias.c
--- fetchmail-6.2.6.alpha1.warn/checkalias.c	2005-02-27 21:19:35.000000000 +0100
+++ fetchmail-6.2.6.alpha1/checkalias.c	2005-07-03 00:37:58.000000000 +0200
@@ -97,7 +97,7 @@
     struct hostent	*he,*he_st;
     struct mxentry	*mxp, *mxrecords;
     struct idlist	*idl;
-    int			namelen;
+    size_t		namelen;
 
     struct hostdata *lead_server = 
 	ctl-&gt;server.lead_server ? ctl-&gt;server.lead_server : &amp;ctl-&gt;server;
@@ -139,11 +139,11 @@
 	 * equal-length case above.  Doing it this way guarantees that
 	 * ep[-1] is a valid reference.
 	 */
-	if (strlen(idl-&gt;id) &gt;= namelen)
+	if (strlen((char *)idl-&gt;id) &gt;= namelen)
 	    continue;
-	ep = (char *)name + (namelen - strlen(idl-&gt;id));
+	ep = (char *)name + (namelen - strlen((char *)idl-&gt;id));
 	/* a suffix led by . must match */
-	if (ep[-1] == '.' &amp;&amp; !strcasecmp(ep, idl-&gt;id))
+	if (ep[-1] == '.' &amp;&amp; !strcasecmp(ep, (char *)idl-&gt;id))
 	    return(TRUE);
     }
 
@@ -230,7 +230,7 @@
     else
     {
 	for (mxp = mxrecords; mxp-&gt;name; mxp++)
-	    if (strcasecmp(ctl-&gt;server.truename, mxp-&gt;name) == 0)
+	    if (strcasecmp(ctl-&gt;server.truename, (char *)mxp-&gt;name) == 0)
 		goto match;
 	return(FALSE);
     match:;
diff -ur fetchmail-6.2.6.alpha1.warn/imap.c fetchmail-6.2.6.alpha1/imap.c
--- fetchmail-6.2.6.alpha1.warn/imap.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/imap.c	2005-07-03 00:34:00.000000000 +0200
@@ -66,7 +66,7 @@
 	     * count, and allocate a malloc area that would overlap
 	     * a portion of the stack.
 	     */
-	    if (count &gt; INT_MAX/sizeof(int))
+	    if (count &gt; INT_MAX/(int)sizeof(int))
 	    {
 		report(stderr, &quot;bogus message count!&quot;);
 		return(PS_PROTOCOL);
@@ -200,7 +200,7 @@
 	dumpSmbNtlmAuthRequest(stdout, &amp;request);
 
     memset(msgbuf,0,sizeof msgbuf);
-    to64frombits (msgbuf, (unsigned char*)&amp;request, SmbLength(&amp;request));
+    to64frombits ((unsigned char *)msgbuf, (unsigned char*)&amp;request, SmbLength(&amp;request));
   
     if (outlevel &gt;= O_MONITOR)
 	report(stdout, &quot;IMAP&gt; %s\n&quot;, msgbuf);
@@ -222,7 +222,7 @@
 	dumpSmbNtlmAuthResponse(stdout, &amp;response);
   
     memset(msgbuf,0,sizeof msgbuf);
-    to64frombits (msgbuf, (unsigned char*)&amp;response, SmbLength(&amp;response));
+    to64frombits ((unsigned char *)msgbuf, (unsigned char*)&amp;response, SmbLength(&amp;response));
 
     if (outlevel &gt;= O_MONITOR)
 	report(stdout, &quot;IMAP&gt; %s\n&quot;, msgbuf);
@@ -240,10 +240,10 @@
 }
 #endif /* NTLM */
 
-static int imap_canonicalize(char *result, char *raw, int maxlen)
+static int imap_canonicalize(char *result, char *raw, size_t maxlen)
 /* encode an IMAP password as per RFC1730's quoting conventions */
 {
-    int i, j;
+    size_t i, j;
 
     j = 0;
     for (i = 0; i &lt; strlen(raw) &amp;&amp; i &lt; maxlen; i++)
@@ -320,6 +320,7 @@
     flag did_stls = FALSE;
 #endif /* SSL_ENABLE */
 
+    (void)greeting;
     /*
      * Assumption: expunges are cheap, so we want to do them
      * after every message unless user said otherwise.
@@ -393,7 +394,8 @@
     if ((ctl-&gt;server.authenticate == A_ANY 
 	 || ctl-&gt;server.authenticate == A_GSSAPI)
 	&amp;&amp; strstr(capabilities, &quot;AUTH=GSSAPI&quot;))
-	if(ok = do_gssauth(sock, &quot;AUTHENTICATE&quot;, &quot;imap&quot;, ctl-&gt;server.truename, ctl-&gt;remotename))
+    {
+        if((ok = do_gssauth(sock, &quot;AUTHENTICATE&quot;, &quot;imap&quot;, ctl-&gt;server.truename, ctl-&gt;remotename)))
 	{
 	    /* SASL cancellation of authentication */
 	    gen_send(sock, &quot;*&quot;);
@@ -402,6 +404,7 @@
 	}
 	else
 	    return ok;
+    }
 #endif /* GSSAPI */
 
 #ifdef KERBEROS_V4
@@ -874,6 +877,8 @@
     flag seen = TRUE;
     int i;
 
+    (void)sock;
+    (void)ctl;
     /* 
      * Expunges change the fetch numbers, but unseen_messages contains
      * indices from before any expungees were done.  So neither the
@@ -905,6 +910,7 @@
     char buf [MSGBUFSIZE+1];
     int	num;
 
+    (void)ctl;
     /* expunges change the fetch numbers */
     number -= expunged;
 
@@ -954,6 +960,7 @@
     char buf [MSGBUFSIZE+1], *cp;
     int	num;
 
+    (void)ctl;
     /* expunges change the fetch numbers */
     number -= expunged;
 
@@ -1028,6 +1035,7 @@
     /* expunges change the fetch numbers */
     /* number -= expunged; */
 
+    (void)ctl;
     for (;;)
     {
 	char buf[MSGBUFSIZE+1];
@@ -1049,6 +1057,7 @@
 {
     int	ok;
 
+    (void)ctl;
     /* expunges change the fetch numbers */
     number -= expunged;
 
@@ -1086,6 +1095,7 @@
 static int imap_mark_seen(int sock, struct query *ctl, int number)
 /* mark the given message as seen */
 {
+    (void)ctl;
     return(gen_transact(sock,
 	imap_version == IMAP4
 	? &quot;STORE %d +FLAGS.SILENT (\\Seen)&quot;
@@ -1096,6 +1106,7 @@
 static int imap_logout(int sock, struct query *ctl)
 /* send logout command */
 {
+    (void)ctl;
     /* if any un-expunged deletions remain, ship an expunge now */
     if (deletions)
 	internal_expunge(sock);
diff -ur fetchmail-6.2.6.alpha1.warn/kerberos.c fetchmail-6.2.6.alpha1/kerberos.c
--- fetchmail-6.2.6.alpha1.warn/kerberos.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/kerberos.c	2005-07-02 23:13:18.000000000 +0200
@@ -65,7 +65,7 @@
      * in network byte order.
      */
 
-    if (result = gen_recv(sock, buf1, sizeof buf1)) {
+    if ((result = gen_recv(sock, buf1, sizeof buf1)) != 0) {
 	return result;
     }
 
@@ -103,7 +103,7 @@
 
     strncpy(srvrealm, (char *)krb_realmofhost(srvinst), (sizeof srvrealm)-1);
     srvrealm[(sizeof srvrealm)-1] = '\0';
-    if (p = strchr(srvinst, '.')) {
+    if ((p = strchr(srvinst, '.')) != NULL) {
       *p = '\0';
     }
 
@@ -121,7 +121,7 @@
 
     memcpy(session, credentials.session, sizeof session);
     memset(&amp;credentials, 0, sizeof credentials);
-    des_key_sched(&amp;session, schedule);
+    des_key_sched(session, schedule);
 
     result = krb_get_tf_fullname(TKT_FILE, tktuser, tktinst, tktrealm);
     if (result) {
@@ -162,7 +162,7 @@
 	return PS_AUTHFAIL;
     }
 
-    to64frombits(buf1, authenticator.dat, authenticator.length);
+    to64frombits((unsigned char *)buf1, authenticator.dat, authenticator.length);
     if (outlevel &gt;= O_MONITOR) {
 	report(stdout, &quot;IMAP&gt; %s\n&quot;, buf1);
     }
@@ -186,7 +186,7 @@
      * checksum it previously sent.
      */
     
-    if (result = gen_recv(sock, buf1, sizeof buf1))
+    if ((result = gen_recv(sock, buf1, sizeof buf1)) != 0)
 	return result;
 
     /* The client must construct data with the first four octets
@@ -216,7 +216,7 @@
 
     des_ecb_encrypt((des_cblock *)buf2, (des_cblock *)buf2, schedule, 0);
     memcpy(challenge2.cstr, buf2, 4);
-    if (ntohl(challenge2.cint) != challenge1.cint + 1) {
+    if ((int32)ntohl(challenge2.cint) != challenge1.cint + 1) {
 	report(stderr, GT_(&quot;challenge mismatch\n&quot;));
 	return PS_AUTHFAIL;
     }	    
@@ -236,7 +236,7 @@
     authenticator.dat[4] = 1;
 
     len = strlen(tktuser);
-    strncpy(authenticator.dat+8, tktuser, len);
+    strncpy((char *)(authenticator.dat+8), tktuser, len);
     authenticator.length = len + 8 + 1;
     while (authenticator.length &amp; 7) {
 	authenticator.length++;
@@ -245,7 +245,7 @@
 	    (des_cblock *)authenticator.dat, authenticator.length, schedule,
 	    &amp;session, 1);
 
-    to64frombits(buf1, authenticator.dat, authenticator.length);
+    to64frombits((unsigned char *)buf1, authenticator.dat, authenticator.length);
 
     /* ship down the response, accept the server's error/ok indication */
     suppress_tags = TRUE;
diff -ur fetchmail-6.2.6.alpha1.warn/md5ify.c fetchmail-6.2.6.alpha1/md5ify.c
--- fetchmail-6.2.6.alpha1.warn/md5ify.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/md5ify.c	2005-07-02 23:07:10.000000000 +0200
@@ -28,7 +28,7 @@
   static char ascii_digest [33];
 
   MD5Init(&amp;context);
-  MD5Update(&amp;context, s, strlen(s));
+  MD5Update(&amp;context, s, strlen((char *)s));
   MD5Final(digest, &amp;context);
   
   for (i = 0;  i &lt; 16;  i++) 
diff -ur fetchmail-6.2.6.alpha1.warn/mxget.c fetchmail-6.2.6.alpha1/mxget.c
--- fetchmail-6.2.6.alpha1.warn/mxget.c	2005-02-27 21:19:35.000000000 +0100
+++ fetchmail-6.2.6.alpha1/mxget.c	2005-07-03 00:36:30.000000000 +0200
@@ -63,12 +63,12 @@
     static char MXHostBuf[PACKETSZ - HFIXEDSZ]; 
     HEADER *hp;
 
-    pmx-&gt;name = (char *)NULL;
+    pmx-&gt;name = NULL;
     pmx-&gt;pref = -1;
     n = res_search(name, C_IN,T_MX, (unsigned char *)&amp;answer, sizeof(answer));
     if (n == -1)
 	return((struct mxentry *)NULL);
-    if (n &gt; sizeof(answer))
+    if ((size_t)n &gt; sizeof(answer))
 	n = sizeof(answer);    	
 
     hp = (HEADER *)&answer;
@@ -76,7 +76,7 @@
     eom = answer + n;
     h_errno = 0;
     for (qdcount = ntohs(hp-&gt;qdcount); qdcount--; cp += n + QFIXEDSZ)
-	if ((n = dn_skipname(cp, eom)) &lt; 0)
+	if ((n = dn_skipname((unsigned char *)cp, (unsigned char *)eom)) &lt; 0)
 	    return((struct mxentry *)NULL);
     buflen = sizeof(MXHostBuf) - 1;
     bp = MXHostBuf;
@@ -84,7 +84,7 @@
     ancount = ntohs(hp-&gt;ancount);
     while (--ancount &gt;= 0 &amp;&amp; cp &lt; eom)
     {
-	if ((n = dn_expand(answer, eom, cp, bp, buflen)) &lt; 0)
+	if ((n = dn_expand((unsigned char *)answer, (unsigned char *)eom, (unsigned char *)cp, bp, buflen)) &lt; 0)
 	    break;
 	cp += n;
 	GETSHORT(type, cp);
@@ -96,11 +96,11 @@
 	    continue;
 	}
 	GETSHORT(pref, cp);
-	if ((n = dn_expand(answer, eom, cp, bp, buflen)) &lt; 0)
+	if ((n = dn_expand((unsigned char *)answer, (unsigned char *)eom, (unsigned char *)cp, bp, buflen)) &lt; 0)
 	    break;
 	cp += n;
 
-	pmx[ind].name = bp;
+	pmx[ind].name = (unsigned char *)bp;
 	pmx[ind].pref = pref;
 	++ind;
 
@@ -111,7 +111,7 @@
 	buflen -= n + 1;
     }
 
-    pmx[ind].name = (char *)NULL;
+    pmx[ind].name = NULL;
     pmx[ind].pref = -1;
     return(pmx);
 }
diff -ur fetchmail-6.2.6.alpha1.warn/odmr.c fetchmail-6.2.6.alpha1/odmr.c
--- fetchmail-6.2.6.alpha1.warn/odmr.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/odmr.c	2005-07-03 00:34:21.000000000 +0200
@@ -35,6 +35,7 @@
 {
     int ok;
 
+    (void)argbuf;
     ok = SMTP_ok(sock);
     if (ok == SM_UNRECOVERABLE)
 	return(PS_PROTOCOL);
@@ -51,6 +52,7 @@
     char buf [MSGBUFSIZE+1];
     struct idlist *qnp;		/* pointer to Q names */
 
+    (void)id;
     if ((ok = SMTP_ehlo(sock, fetchmailhost, 
 			ctl-&gt;server.esmtp_name, ctl-&gt;server.esmtp_password,
 			&amp;opts)))
@@ -80,11 +82,11 @@
      */
     buf[0] = '\0';
     for (qnp = ctl-&gt;domainlist; qnp; qnp = qnp-&gt;next)
-	if (strlen(buf) + strlen(qnp-&gt;id) + 1 &gt;= sizeof(buf))
+	if (strlen(buf) + strlen((char *)qnp-&gt;id) + 1 &gt;= sizeof(buf))
 	    break;
 	else
 	{
-	    strcat(buf, qnp-&gt;id);
+	    strcat(buf, (char *)qnp-&gt;id);
 	    strcat(buf, &quot;,&quot;);
 	}
     buf[strlen(buf) - 1] = '\0';	/* nuke final comma */
diff -ur fetchmail-6.2.6.alpha1.warn/pop3.c fetchmail-6.2.6.alpha1/pop3.c
--- fetchmail-6.2.6.alpha1.warn/pop3.c	2005-05-16 19:57:32.000000000 +0200
+++ fetchmail-6.2.6.alpha1/pop3.c	2005-07-03 00:29:55.000000000 +0200
@@ -87,7 +87,7 @@
 	dumpSmbNtlmAuthRequest(stdout, &amp;request);
 
     memset(msgbuf,0,sizeof msgbuf);
-    to64frombits (msgbuf, (unsigned char*)&amp;request, SmbLength(&amp;request));
+    to64frombits ((unsigned char *)msgbuf, (unsigned char*)&amp;request, SmbLength(&amp;request));
   
     if (outlevel &gt;= O_MONITOR)
 	report(stdout, &quot;POP3&gt; %s\n&quot;, msgbuf);
@@ -98,7 +98,7 @@
     if ((gen_recv(sock, msgbuf, sizeof msgbuf)))
 	return result;
   
-    len = from64tobits ((unsigned char*)&amp;challenge, msgbuf, sizeof(msgbuf));
+    len = from64tobits ((char*)&amp;challenge, msgbuf, sizeof(msgbuf));
     
     if (outlevel &gt;= O_DEBUG)
 	dumpSmbNtlmAuthChallenge(stdout, &amp;challenge);
@@ -109,7 +109,7 @@
 	dumpSmbNtlmAuthResponse(stdout, &amp;response);
   
     memset(msgbuf,0,sizeof msgbuf);
-    to64frombits (msgbuf, (unsigned char*)&amp;response, SmbLength(&amp;response));
+    to64frombits ((unsigned char *)msgbuf, (unsigned char*)&amp;response, SmbLength(&amp;response));
 
     if (outlevel &gt;= O_MONITOR)
 	report(stdout, &quot;POP3&gt; %s\n&quot;, msgbuf);
@@ -349,8 +349,8 @@
 		    if (strncasecmp(buffer, &quot;rpa&quot;, 3) == 0)
 			has_rpa = TRUE;
 		}
-		if (has_rpa &amp;&amp; !POP3_auth_rpa(ctl-&gt;remotename, 
-					      ctl-&gt;password, sock))
+		if (has_rpa &amp;&amp; !POP3_auth_rpa((unsigned char *)ctl-&gt;remotename, 
+					      (unsigned char *)ctl-&gt;password, sock))
 		    return(PS_SUCCESS);
 	    }
 
@@ -1156,6 +1156,7 @@
 static int pop3_mark_seen(int sock, struct query *ctl, int number)
 /* mark a given message as seen */
 {
+    (void)sock;
     mark_uid_seen(ctl, number);
     return(PS_SUCCESS);
 }
diff -ur fetchmail-6.2.6.alpha1.warn/report.c fetchmail-6.2.6.alpha1/report.c
--- fetchmail-6.2.6.alpha1.warn/report.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/report.c	2005-07-02 22:09:32.000000000 +0200
@@ -241,7 +241,7 @@
 		       partial_message_size - partial_message_size_used,
 		       message, args);
 
-	if (n &lt; partial_message_size - partial_message_size_used)
+	if ((unsigned)n &lt; partial_message_size - partial_message_size_used)
         {
 	    partial_message_size_used += n;
 	    break;
@@ -258,7 +258,7 @@
 		      partial_message_size - partial_message_size_used,
 		      message, a1, a2, a3, a4, a5, a6, a7, a8);
 
-	if (n &lt; partial_message_size - partial_message_size_used)
+	if ((unsigned)n &lt; partial_message_size - partial_message_size_used)
         {
 	    partial_message_size_used += n;
 	    break;
@@ -318,7 +318,7 @@
 		       partial_message_size - partial_message_size_used,
 		       message, args);
 
-	if (n &lt; partial_message_size - partial_message_size_used)
+	if ((unsigned)n &lt; partial_message_size - partial_message_size_used)
         {
 	    partial_message_size_used += n;
 	    break;
@@ -335,7 +335,7 @@
 		      partial_message_size - partial_message_size_used,
 		      message, a1, a2, a3, a4, a5, a6, a7, a8);
 
-	if (n &lt; partial_message_size - partial_message_size_used)
+	if ((unsigned)n &lt; partial_message_size - partial_message_size_used)
         {
 	    partial_message_size_used += n;
 	    break;
diff -ur fetchmail-6.2.6.alpha1.warn/rfc822.c fetchmail-6.2.6.alpha1/rfc822.c
--- fetchmail-6.2.6.alpha1.warn/rfc822.c	2005-02-27 21:19:35.000000000 +0100
+++ fetchmail-6.2.6.alpha1/rfc822.c	2005-07-02 22:45:08.000000000 +0200
@@ -44,7 +44,7 @@
 unsigned char *reply_hack(
 	unsigned char *buf		/* header to be hacked */,
 	const unsigned char *host	/* server hostname */,
-        int *length)
+        size_t *length)
 /* hack message headers so replies will work properly */
 {
     unsigned char *from, *cp, last_nws = '\0', *parens_from = NULL;
@@ -53,20 +53,20 @@
     int addresscount = 1;
 #endif /* MAIN */
 
-    if (strncasecmp(&quot;From:&quot;, buf, 5)
-	&amp;&amp; strncasecmp(&quot;To:&quot;, buf, 3)
-	&amp;&amp; strncasecmp(&quot;Reply-To:&quot;, buf, 9)
-	&amp;&amp; strncasecmp(&quot;Return-Path:&quot;, buf, 12)
-	&amp;&amp; strncasecmp(&quot;Cc:&quot;, buf, 3)
-	&amp;&amp; strncasecmp(&quot;Bcc:&quot;, buf, 4)
-	&amp;&amp; strncasecmp(&quot;Resent-From:&quot;, buf, 12)
-	&amp;&amp; strncasecmp(&quot;Resent-To:&quot;, buf, 10)
-	&amp;&amp; strncasecmp(&quot;Resent-Cc:&quot;, buf, 10)
-	&amp;&amp; strncasecmp(&quot;Resent-Bcc:&quot;, buf, 11)
-	&amp;&amp; strncasecmp(&quot;Apparently-From:&quot;, buf, 16)
-	&amp;&amp; strncasecmp(&quot;Apparently-To:&quot;, buf, 14)
-	&amp;&amp; strncasecmp(&quot;Sender:&quot;, buf, 7)
-	&amp;&amp; strncasecmp(&quot;Resent-Sender:&quot;, buf, 14)
+    if (strncasecmp(&quot;From:&quot;, (char *)buf, 5)
+	&amp;&amp; strncasecmp(&quot;To:&quot;, (char *)buf, 3)
+	&amp;&amp; strncasecmp(&quot;Reply-To:&quot;, (char *)buf, 9)
+	&amp;&amp; strncasecmp(&quot;Return-Path:&quot;, (char *)buf, 12)
+	&amp;&amp; strncasecmp(&quot;Cc:&quot;, (char *)buf, 3)
+	&amp;&amp; strncasecmp(&quot;Bcc:&quot;, (char *)buf, 4)
+	&amp;&amp; strncasecmp(&quot;Resent-From:&quot;, (char *)buf, 12)
+	&amp;&amp; strncasecmp(&quot;Resent-To:&quot;, (char *)buf, 10)
+	&amp;&amp; strncasecmp(&quot;Resent-Cc:&quot;, (char *)buf, 10)
+	&amp;&amp; strncasecmp(&quot;Resent-Bcc:&quot;, (char *)buf, 11)
+	&amp;&amp; strncasecmp(&quot;Apparently-From:&quot;, (char *)buf, 16)
+	&amp;&amp; strncasecmp(&quot;Apparently-To:&quot;, (char *)buf, 14)
+	&amp;&amp; strncasecmp(&quot;Sender:&quot;, (char *)buf, 7)
+	&amp;&amp; strncasecmp(&quot;Resent-Sender:&quot;, (char *)buf, 14)
        ) {
 	return(buf);
     }
@@ -79,7 +79,7 @@
     for (cp = buf; *cp; cp++)
 	if (*cp == ',' || isspace(*cp))
 	    addresscount++;
-    buf = (unsigned char *)xrealloc(buf, strlen(buf) + addresscount * (strlen(host) + 1) + 1);
+    buf = (unsigned char *)xrealloc(buf, strlen((char *)buf) + addresscount * (strlen((const char *)host) + 1) + 1);
 #endif /* MAIN */
 
     /*
@@ -143,8 +143,8 @@
 		    while (isspace(*from) || (*from == ','))
 			--from;
 		    from++;
-		    hostlen = strlen(host);
-		    for (cp = from + strlen(from); cp &gt;= from; --cp)
+		    hostlen = strlen((const char *)host);
+		    for (cp = from + strlen((char *)from); cp &gt;= from; --cp)
 			cp[hostlen+1] = *cp;
 		    *from++ = '@';
 		    memcpy(from, host, hostlen);
@@ -165,7 +165,7 @@
 	    case 2:	/* we're in a string */
 		if (*from == '&quot;')
 		{
-		    char	*bp;
+		    unsigned char *bp;
 		    int		bscount;
 
 		    bscount = 0;
@@ -186,8 +186,8 @@
 		    {
 			int hostlen;
 
-			hostlen = strlen(host);
-			for (cp = from + strlen(from); cp &gt;= from; --cp)
+			hostlen = strlen((const char *)host);
+			for (cp = from + strlen((char *)from); cp &gt;= from; --cp)
 			    cp[hostlen+1] = *cp;
 			*from++ = '@';
 			memcpy(from, host, hostlen);
@@ -211,7 +211,7 @@
     if (outlevel &gt;= O_DEBUG)
 	report_complete(stdout, GT_(&quot;Rewritten version is %s\n&quot;), buf);
 #endif /* MAIN */
-    *length = strlen(buf);
+    *length = strlen((char *)buf);
     return(buf);
 }
 
@@ -219,7 +219,7 @@
 /* parse addresses in succession out of a specified RFC822 header */
 {
     static unsigned char address[BUFSIZ];
-    static int tp;
+    static size_t tp;
     static const unsigned char *hp;
     static int	state, oldstate;
 #ifdef MAIN
diff -ur fetchmail-6.2.6.alpha1.warn/rpa.c fetchmail-6.2.6.alpha1/rpa.c
--- fetchmail-6.2.6.alpha1.warn/rpa.c	2005-07-02 21:58:49.000000000 +0200
+++ fetchmail-6.2.6.alpha1/rpa.c	2005-07-02 23:16:35.000000000 +0200
@@ -217,11 +217,11 @@
 
     bufp      = buf;
     *(bufp++) = HDR;
-    LenAppend(&amp;bufp, 11+2+strlen(userid)+1+Cul+1+Rul );
+    LenAppend(&amp;bufp, 11+2+strlen((char *)userid)+1+Cul+1+Rul );
     memcpy(bufp, MECH, 11); bufp += 11;
     *(bufp++) = 0;
-    *(bufp++) = strlen(userid);
-    memcpy(bufp,userid,strlen(userid)); bufp += strlen(userid);
+    *(bufp++) = strlen((char *)userid);
+    memcpy(bufp,userid,strlen((char *)userid)); bufp += strlen((char *)userid);
     GenChallenge(Cu,Cul);
     *(bufp++) = Cul;
     memcpy(bufp, Cu, Cul);  bufp += Cul;
@@ -389,7 +389,7 @@
 	    bufp++;
 /*      if (*bufp == ' ') bufp++; */
 	    if (argbuf != NULL)
-		strcpy(argbuf,bufp);
+		strcpy((char *)argbuf,bufp);
 	    ok=0;
 	}
 	else if (strcmp(buf,&quot;-ERR&quot;) == 0)
@@ -771,7 +771,7 @@
     else
     {
 	ptr = rbuf;
-	len = strlen(passphrase);
+	len = strlen((char *)passphrase);
     }
     md5(ptr,len,rbuf);
     return(0);
diff -ur fetchmail-6.2.6.alpha1.warn/sink.c fetchmail-6.2.6.alpha1/sink.c
--- fetchmail-6.2.6.alpha1.warn/sink.c	2005-06-29 23:13:56.000000000 +0200
+++ fetchmail-6.2.6.alpha1/sink.c	2005-07-02 22:58:51.000000000 +0200
@@ -127,13 +127,13 @@
 	    int		portnum = SMTP_PORT;
 #endif /* INET6_ENABLE */
 
-	    xalloca(parsed_host, char *, strlen(idp-&gt;id) + 1);
+	    xalloca(parsed_host, char *, strlen((char *)idp-&gt;id) + 1);
 
-	    ctl-&gt;smtphost = idp-&gt;id;  /* remember last host tried. */
+	    ctl-&gt;smtphost = (char *)idp-&gt;id;  /* remember last host tried. */
 	    if(ctl-&gt;smtphost[0]=='/')
 		ctl-&gt;listener = LMTP_MODE;
 
-	    strcpy(parsed_host, idp-&gt;id);
+	    strcpy(parsed_host, (char *)idp-&gt;id);
 	    if ((cp = strrchr(parsed_host, '/')))
 	    {
 		*cp++ = 0;
@@ -277,6 +277,7 @@
     return addr;
 }
 
+/* FIXME? 'message' is not used */
 static int send_bouncemail(struct query *ctl, struct msgblk *msg,
 			   int userclass, char *message,
 			   int nerrors, char *errors[])
@@ -364,7 +365,7 @@
             if (idp-&gt;val.status.mark == userclass)
             {
                 char	*error;
-                SockPrintf(sock, &quot;%s\r\n&quot;, rcpt_address (ctl, idp-&gt;id, 1));
+                SockPrintf(sock, &quot;%s\r\n&quot;, rcpt_address (ctl, (char *)idp-&gt;id, 1));
                 
                 if (nerrors == 1) error = errors[0];
                 else if (nerrors &lt;= nusers)
@@ -392,7 +393,7 @@
 		/* Minimum RFC1894 compliance + Diagnostic-Code field */
 		SockPrintf(sock, &quot;\r\n&quot;);
 		SockPrintf(sock, &quot;Final-Recipient: rfc822; %s\r\n&quot;, 
-			   rcpt_address (ctl, idp-&gt;id, 1));
+			   rcpt_address (ctl, (char *)idp-&gt;id, 1));
 		SockPrintf(sock, &quot;Last-Attempt-Date: %s\r\n&quot;, rfc822timestamp());
 		SockPrintf(sock, &quot;Action: failed\r\n&quot;);
 
@@ -587,7 +588,7 @@
     }
 }
 
-static int handle_smtp_report_without_bounce(struct query *ctl, struct msgblk *msg)
+static int handle_smtp_report_without_bounce(struct query *ctl)
 /* handle SMTP errors based on the content of SMTP_response */
 /* atleast one PS_TRANSIENT: do not send the bounce mail, keep the mail;
  * no PS_TRANSIENT, atleast one PS_SUCCESS: send the bounce mail, delete the mail;
@@ -750,7 +751,7 @@
 	if (idp-&gt;val.status.mark == XMIT_ACCEPT)
 	{
 	    fprintf(sinkfp, &quot;RCPT TO: %s\r\n&quot;,
-		rcpt_address (ctl, idp-&gt;id, 1));
+		    rcpt_address (ctl, (char *)idp-&gt;id, 1));
 	    (*good_addresses)++;
 	}
 
@@ -939,7 +940,7 @@
 	if (idp-&gt;val.status.mark == XMIT_ACCEPT)
 	{
 	    const char *address;
-	    address = rcpt_address (ctl, idp-&gt;id, 1);
+	    address = rcpt_address (ctl, (char *)idp-&gt;id, 1);
 	    if ((smtp_err = SMTP_rcpt(ctl-&gt;smtp_socket, address)) == SM_UNRECOVERABLE)
 	    {
 		smtp_close(ctl, 0);
@@ -949,7 +950,7 @@
 		(*good_addresses)++;
 	    else
 	    {
-		switch (handle_smtp_report_without_bounce(ctl, msg))
+		switch (handle_smtp_report_without_bounce(ctl))
 		{
 		    case PS_TRANSIENT:
 		    force_transient_error = 1;
@@ -1059,7 +1060,7 @@
 }
 
 static int open_mda_sink(struct query *ctl, struct msgblk *msg,
-	      int *good_addresses, int *bad_addresses)
+			 int *good_addresses)
 /* open a stream to a local MDA */
 {
 #ifdef HAVE_SETEUID
@@ -1088,7 +1089,7 @@
 	nameslen = 0;
 	for (idp = msg-&gt;recipients; idp; idp = idp-&gt;next)
 	    if ((idp-&gt;val.status.mark == XMIT_ACCEPT))
-		nameslen += (strlen(idp-&gt;id) + 1);	/* string + ' ' */
+		nameslen += (strlen((char *)idp-&gt;id) + 1); /* string + ' ' */
 	if ((*good_addresses == 0))
 	    nameslen = strlen(run.postmaster);
 
@@ -1101,7 +1102,7 @@
 	    for (idp = msg-&gt;recipients; idp; idp = idp-&gt;next)
 		if (idp-&gt;val.status.mark == XMIT_ACCEPT)
 		{
-		    strcat(names, idp-&gt;id);
+		    strcat(names, (char *)idp-&gt;id);
 		    strcat(names, &quot; &quot;);
 		}
 	    names[--nameslen] = '\0';	/* chop trailing space */
@@ -1274,7 +1275,7 @@
     }
 
     if (ctl-&gt;mda)		/* must deliver through an MDA */
-	return(open_mda_sink(ctl, msg, good_addresses, bad_addresses));
+	return(open_mda_sink(ctl, msg, good_addresses));
 
     return(PS_SUCCESS);
 }
@@ -1463,7 +1464,7 @@
     return(TRUE);
 }
 
-int open_warning_by_mail(struct query *ctl, struct msgblk *msg)
+int open_warning_by_mail(struct query *ctl)
 /* set up output sink for a mailed warning to calling user */
 {
     int	good, bad;
@@ -1496,7 +1497,7 @@
 
     if (!MULTIDROP(ctl))		/* send to calling user */
     {
-	save_str(&amp;reply.recipients, ctl-&gt;localnames-&gt;id, XMIT_ACCEPT);
+	save_str(&amp;reply.recipients, (char *)ctl-&gt;localnames-&gt;id, XMIT_ACCEPT);
 	status = open_sink(ctl, &amp;reply, &amp;good, &amp;bad);
 	free_str_list(&amp;reply.recipients);
     }
diff -ur fetchmail-6.2.6.alpha1.warn/smbencrypt.c fetchmail-6.2.6.alpha1/smbencrypt.c
--- fetchmail-6.2.6.alpha1.warn/smbencrypt.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/smbencrypt.c	2005-07-02 23:29:00.000000000 +0200
@@ -59,12 +59,6 @@
   return(dest);
 }
 
-size_t skip_multibyte_char(char c)
-{
-return 0;
-}
-
-
 /*******************************************************************
 safe string copy into a known length string. maxlength does not
 include the terminating zero.
@@ -103,15 +97,9 @@
 while (*s)
   {
     {
-    size_t skip = skip_multibyte_char( *s );
-    if( skip != 0 )
-      s += skip;
-    else
-      {
       if (islower((unsigned char)*s))
 	*s = toupper((unsigned char)*s);
       s++;
-      }
     }
   }
 }
diff -ur fetchmail-6.2.6.alpha1.warn/smbutil.c fetchmail-6.2.6.alpha1/smbutil.c
--- fetchmail-6.2.6.alpha1.warn/smbutil.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/smbutil.c	2005-07-02 23:29:26.000000000 +0200
@@ -74,7 +74,7 @@
 
 static void dumpRaw(FILE *fp, unsigned char *buf, size_t len)
   {
-  int i;
+  size_t i;
   
   for (i=0; i&lt;len; ++i)
     fprintf(fp,&quot;%02x &quot;,buf[i]);
@@ -84,7 +84,7 @@
 
 static char *unicodeToString(char *p, size_t len)
   {
-  int i;
+  size_t i;
   static char buf[1024];
 
   assert(len+1 &lt; sizeof buf);
diff -ur fetchmail-6.2.6.alpha1.warn/smtp.c fetchmail-6.2.6.alpha1/smtp.c
--- fetchmail-6.2.6.alpha1.warn/smtp.c	2005-04-25 00:37:31.000000000 +0200
+++ fetchmail-6.2.6.alpha1/smtp.c	2005-07-02 23:01:15.000000000 +0200
@@ -104,16 +104,16 @@
 		}
 		if (outlevel &gt;= O_DEBUG)
 			report(stdout, GT_(&quot;Challenge decoded: %s\n&quot;), b64buf);
-		hmac_md5(password, strlen(password),
-			 b64buf, strlen(b64buf), digest, sizeof(digest));
+		hmac_md5((unsigned char *)password, strlen(password),
+			 (unsigned char *)b64buf, strlen(b64buf), digest, sizeof(digest));
 		snprintf(tmp, sizeof(tmp),
 		&quot;%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x&quot;,
 		username,  digest[0], digest[1], digest[2], digest[3],
 		digest[4], digest[5], digest[6], digest[7], digest[8],
 		digest[9], digest[10], digest[11], digest[12], digest[13],
 		digest[14], digest[15]);
-
-		to64frombits(b64buf, tmp, strlen(tmp));
+		
+		to64frombits((unsigned char *)b64buf, (unsigned char *)tmp, strlen(tmp));
 		SockPrintf(sock, &quot;%s\r\n&quot;, b64buf);
 		SMTP_ok(sock);
 	}
@@ -129,7 +129,7 @@
 			if (tmp[c] == '^')
 				tmp[c] = '\0';
 		}
-		to64frombits(b64buf, tmp, len);
+		to64frombits((unsigned char *)b64buf, (unsigned char *)tmp, len);
 		SockPrintf(sock, &quot;AUTH PLAIN %s\r\n&quot;, b64buf);
 		SMTP_ok(sock);
 	}
@@ -152,7 +152,7 @@
 			SMTP_auth_error(sock, GT_(&quot;Bad base64 reply from server.\n&quot;));
 			return;
 		}
-		to64frombits(b64buf, username, strlen(username));
+		to64frombits((unsigned char *)b64buf, (unsigned char *)username, strlen(username));
 		SockPrintf(sock, &quot;%s\r\n&quot;, b64buf);
 		SockRead(sock, smtp_response, sizeof(smtp_response) - 1);
 		strncpy(tmp, smtp_response, sizeof(tmp));
@@ -168,7 +168,7 @@
 			SMTP_auth_error(sock, GT_(&quot;Bad base64 reply from server.\n&quot;));
 			return;
 		}
-		to64frombits(b64buf, password, strlen(password));
+		to64frombits((unsigned char *)b64buf, (unsigned char *)password, strlen(password));
 		SockPrintf(sock, &quot;%s\r\n&quot;, b64buf);
 		SMTP_ok(sock);
 	}
diff -ur fetchmail-6.2.6.alpha1.warn/socket.c fetchmail-6.2.6.alpha1/socket.c
--- fetchmail-6.2.6.alpha1.warn/socket.c	2005-04-25 18:48:01.000000000 +0200
+++ fetchmail-6.2.6.alpha1/socket.c	2005-07-02 22:13:19.000000000 +0200
@@ -302,6 +302,7 @@
 
  ret:
 #else /* NET_SECURITY */
+    (void)options;
 #ifdef HAVE_INNER_CONNECT
     i = inner_connect(ai0, NULL, 0, NULL, NULL, &quot;fetchmail&quot;, NULL);
     if (i &gt;= 0)
@@ -783,13 +784,13 @@
 		_depth0ck = 1;
 		
 		if (outlevel == O_VERBOSE) {
-			if ((i = X509_NAME_get_text_by_NID(issuer, NID_organizationName, buf, sizeof(buf))) != -1) {
+			if ((i = X509_NAME_get_text_by_NID(issuer, NID_organizationName, buf, sizeof(buf))) != -1U) {
 				report(stdout, GT_(&quot;Issuer Organization: %s\n&quot;), buf);
 				if (i &gt;= sizeof(buf) - 1)
 					report(stdout, GT_(&quot;Warning: Issuer Organization Name too long (possibly truncated).\n&quot;));
 			} else
 				report(stdout, GT_(&quot;Unknown Organization\n&quot;));
-			if ((i = X509_NAME_get_text_by_NID(issuer, NID_commonName, buf, sizeof(buf))) != -1) {
+			if ((i = X509_NAME_get_text_by_NID(issuer, NID_commonName, buf, sizeof(buf))) != -1U) {
 				report(stdout, GT_(&quot;Issuer CommonName: %s\n&quot;), buf);
 				if (i &gt;= sizeof(buf) - 1)
 					report(stdout, GT_(&quot;Warning: Issuer CommonName too long (possibly truncated).\n&quot;));
@@ -852,7 +853,7 @@
 			te = text + sizeof(text);
 			for (i = 0; i &lt; dsz; i++) {
 				esz = snprintf(tp, te - tp, i &gt; 0 ? &quot;:%02X&quot; : &quot;%02X&quot;, digest[i]);
-				if (esz &gt;= te - tp) {
+				if (esz &gt;= (size_t)(te - tp)) {
 					report(stderr, GT_(&quot;Digest text buffer too small!\n&quot;));
 					return (0);
 				}
diff -ur fetchmail-6.2.6.alpha1.warn/transact.c fetchmail-6.2.6.alpha1/transact.c
--- fetchmail-6.2.6.alpha1.warn/transact.c	2005-02-27 21:19:35.000000000 +0100
+++ fetchmail-6.2.6.alpha1/transact.c	2005-07-03 00:35:54.000000000 +0200
@@ -83,9 +83,9 @@
     {
 	char	*cp;
 
-	for (cp = nxtaddr((const unsigned char *)hdr);
+	for (cp = (char *)nxtaddr((const unsigned char *)hdr);
 	     cp != NULL;
-	     cp = nxtaddr(NULL))
+	     cp = (char *)nxtaddr(NULL))
 	{
 	    char	*atsign;
 
@@ -106,11 +106,11 @@
 	    {
 		int sl = strlen(ctl-&gt;server.qvirtual);
  
-		if (!strncasecmp((char *)cp, ctl-&gt;server.qvirtual, sl))
+		if (!strncasecmp(cp, ctl-&gt;server.qvirtual, sl))
 		    cp += sl;
 	    }
 
-	    if ((atsign = strchr((char *)cp, '@'))) {
+	    if ((atsign = strchr(cp, '@'))) {
 		struct idlist	*idp;
 
 		/*
@@ -129,7 +129,7 @@
 			if (outlevel &gt;= O_DEBUG)
 			    report(stdout, GT_(&quot;passed through %s matching %s\n&quot;), 
 				  cp, idp-&gt;id);
-			save_str(xmit_names, (const char *)cp, XMIT_ACCEPT);
+			save_str(xmit_names, cp, XMIT_ACCEPT);
 			accept_count++;
 			goto nomap;
 		    }
@@ -581,7 +581,7 @@
 		if ( ctl-&gt;mimedecode )
 		{
 		    char *tcp;
-		    UnMimeHeader(line);
+		    UnMimeHeader((unsigned char *)line);
 		    /* the line is now shorter. So we retrace back till we find our terminating
 		     * combination \n\0, we move backwards to make sure that we don't catch som
 		     * \n\0 stored in the decoded part of the message */
@@ -703,7 +703,9 @@
 	}
 
 	if (ctl-&gt;rewrite)
-	    line = reply_hack(line, ctl-&gt;server.truename, &amp;linelen);
+	    line = (char *)reply_hack((unsigned char *)line,
+				      (unsigned char *)ctl-&gt;server.truename,
+				      &amp;linelen);
 
 	/*
 	 * OK, this is messy.  If we're forwarding by SMTP, it's the
@@ -732,7 +734,7 @@
 	 * Return-Path.
 	 *
 	 */
-	if ((already_has_return_path==FALSE) &amp;&amp; !strncasecmp(&quot;Return-Path:&quot;, line, 12) &amp;&amp; (cp = nxtaddr(line)))
+	if ((already_has_return_path==FALSE) &amp;&amp; !strncasecmp(&quot;Return-Path:&quot;, line, 12) &amp;&amp; (cp = (char *)nxtaddr((unsigned char *)line)))
 	{
 	    already_has_return_path = TRUE;
 	    if (cp[0]=='\0')	/* nxtaddr() strips the brackets... */
@@ -914,8 +916,8 @@
 	MD5_CTX context;
 
 	MD5Init(&amp;context);
-	MD5Update(&amp;context, msgblk.headers, strlen(msgblk.headers));
-	MD5Final(ctl-&gt;digest, &amp;context);
+	MD5Update(&amp;context, (unsigned char *)msgblk.headers, strlen(msgblk.headers));
+	MD5Final((unsigned char *)ctl-&gt;digest, &amp;context);
 
 	if (!received_for &amp;&amp; env_offs == -1 &amp;&amp; !delivered_to)
 	{
@@ -955,7 +957,8 @@
      */
 
     /* Check for MIME headers indicating possible 8-bit data */
-    ctl-&gt;mimemsg = MimeBodyType(msgblk.headers, ctl-&gt;mimedecode);
+    ctl-&gt;mimemsg = MimeBodyType((unsigned char *)msgblk.headers,
+				ctl-&gt;mimedecode);
 
 #ifdef SDPS_ENABLE
     if (ctl-&gt;server.sdps &amp;&amp; sdps_envfrom)
@@ -983,16 +986,16 @@
      * is true for most mailing list packages.
      */
     if( !msgblk.return_path[0] ){
-	char *ap = NULL;
-	if (resent_sender_offs &gt;= 0 &amp;&amp; (ap = nxtaddr(msgblk.headers + resent_sender_offs)));
-	else if (sender_offs &gt;= 0 &amp;&amp; (ap = nxtaddr(msgblk.headers + sender_offs)));
-	else if (resent_from_offs &gt;= 0 &amp;&amp; (ap = nxtaddr(msgblk.headers + resent_from_offs)));
-	else if (from_offs &gt;= 0 &amp;&amp; (ap = nxtaddr(msgblk.headers + from_offs)));
-	else if (reply_to_offs &gt;= 0 &amp;&amp; (ap = nxtaddr(msgblk.headers + reply_to_offs)));
-	else if (app_from_offs &gt;= 0 &amp;&amp; (ap = nxtaddr(msgblk.headers + app_from_offs)));
+	unsigned char *ap = NULL;
+	if (resent_sender_offs &gt;= 0 &amp;&amp; (ap = nxtaddr((unsigned char *)msgblk.headers + resent_sender_offs)));
+	else if (sender_offs &gt;= 0 &amp;&amp; (ap = nxtaddr((unsigned char *)msgblk.headers + sender_offs)));
+	else if (resent_from_offs &gt;= 0 &amp;&amp; (ap = nxtaddr((unsigned char *)msgblk.headers + resent_from_offs)));
+	else if (from_offs &gt;= 0 &amp;&amp; (ap = nxtaddr((unsigned char *)msgblk.headers + from_offs)));
+	else if (reply_to_offs &gt;= 0 &amp;&amp; (ap = nxtaddr((unsigned char *)msgblk.headers + reply_to_offs)));
+	else if (app_from_offs &gt;= 0 &amp;&amp; (ap = nxtaddr((unsigned char *)msgblk.headers + app_from_offs)));
 	/* multi-line MAIL FROM addresses confuse SMTP terribly */
-	if (ap &amp;&amp; !strchr(ap, '\n')) {
-	    strncpy(msgblk.return_path, ap, sizeof(msgblk.return_path));
+	if (ap &amp;&amp; !strchr((char *)ap, '\n')) {
+	    strncpy(msgblk.return_path, (char *)ap, sizeof(msgblk.return_path));
 	    msgblk.return_path[sizeof(msgblk.return_path)-1] = '\0';
 	}
     }
@@ -1071,7 +1074,7 @@
 	}
     }
     else	/* it's a single-drop box, use first localname */
-	save_str(&amp;msgblk.recipients, ctl-&gt;localnames-&gt;id, XMIT_ACCEPT);
+	save_str(&amp;msgblk.recipients, (char *)ctl-&gt;localnames-&gt;id, XMIT_ACCEPT);
 
 
     /*
@@ -1169,7 +1172,7 @@
 			if (idp-&gt;val.status.mark == XMIT_ACCEPT)
 			    break;	/* only report first address */
 		    snprintf(buf+1, sizeof(buf)-1,
-			    &quot;for %s&quot;, rcpt_address (ctl, idp-&gt;id, 1));
+			     &quot;for %s&quot;, rcpt_address (ctl, (char *)idp-&gt;id, 1));
 		    snprintf(buf+strlen(buf), sizeof(buf)-strlen(buf)-1,
 			    &quot; (%s); &quot;,
 			    MULTIDROP(ctl) ? &quot;multi-drop&quot; : &quot;single-drop&quot;);
@@ -1238,14 +1241,14 @@
 	    errlen = strlen(errhd);
 	    for (idp = msgblk.recipients; idp; idp = idp-&gt;next)
 		if (idp-&gt;val.status.mark == XMIT_RCPTBAD)
-		    errlen += strlen(idp-&gt;id) + 2;
+		    errlen += strlen((char *)idp-&gt;id) + 2;
 
 	    xalloca(errmsg, char *, errlen+3);
 	    (void) strcpy(errmsg, errhd);
 	    for (idp = msgblk.recipients; idp; idp = idp-&gt;next)
 		if (idp-&gt;val.status.mark == XMIT_RCPTBAD)
 		{
-		    strcat(errmsg, idp-&gt;id);
+		    strcat(errmsg, (char *)idp-&gt;id);
 		    if (idp-&gt;next)
 			strcat(errmsg, &quot;, &quot;);
 		}
@@ -1293,7 +1296,7 @@
     while (protocol-&gt;delimited || len &gt; 0)
     {
 	set_timeout(mytimeout);
-	if ((linelen = SockRead(sock, inbufp, sizeof(buf)-4-(inbufp-buf)))==-1)
+	if ((linelen = SockRead(sock, (char *)inbufp, sizeof(buf)-4-(inbufp-buf)))==-1)
 	{
 	    set_timeout(0);
 	    release_sink(ctl);
@@ -1355,7 +1358,7 @@
 	    buf[MSGBUFSIZE+2] = '\n';
 	    buf[MSGBUFSIZE+3] = '\0';
 
-	    n = stuffline(ctl, buf);
+	    n = stuffline(ctl, (char *)buf);
 
 	    if (n &lt; 0)
 	    {
@@ -1503,7 +1506,7 @@
     va_end(ap);
 
     snprintf(buf+strlen(buf), sizeof(buf)-strlen(buf), &quot;\r\n&quot;);
-    if (SockWrite(sock, buf, strlen(buf)) &lt; strlen(buf)) {
+    if (SockWrite(sock, buf, strlen(buf)) &lt; 0) {
 	/* short write, bail out */
 	return PS_SOCKET;
     }
diff -ur fetchmail-6.2.6.alpha1.warn/uid.c fetchmail-6.2.6.alpha1/uid.c
--- fetchmail-6.2.6.alpha1.warn/uid.c	2005-03-06 16:23:53.000000000 +0100
+++ fetchmail-6.2.6.alpha1/uid.c	2005-07-02 23:04:18.000000000 +0200
@@ -319,11 +319,11 @@
 	continue;
 
     *end = (struct idlist *)xmalloc(sizeof(struct idlist));
-    (*end)-&gt;id = str1 ? xstrdup(str1) : (char *)NULL;
+    (*end)-&gt;id = (unsigned char *)(str1 ? xstrdup(str1) : NULL);
     if (str2)
-	(*end)-&gt;val.id2 = xstrdup(str2);
+	(*end)-&gt;val.id2 = (unsigned char *)xstrdup(str2);
     else
-	(*end)-&gt;val.id2 = (char *)NULL;
+	(*end)-&gt;val.id2 = NULL;
     (*end)-&gt;next = (struct idlist *)NULL;
 }
 
@@ -366,7 +366,7 @@
     if ( !str )
         return -1;
     for( walk = *idl, nr = 0; walk; nr ++, walk = walk-&gt;next )
-        if( strcmp( str, walk-&gt;id) == 0 )
+        if( strcmp( str, (char *)walk-&gt;id) == 0 )
 	    return nr;
     return -1;
 }
@@ -379,7 +379,7 @@
     if ( !str )
         return -1;
     for( walk = *idl, nr = 0; walk; nr ++, walk = walk-&gt;next )
-        if( strcmp( str, walk-&gt;id) == 0 )
+        if( strcmp( str, (char *)walk-&gt;id) == 0 )
 	    ret = nr;
     return ret;
 }
@@ -392,7 +392,7 @@
     if (!str)
         return;
     for(walk = *idl, nr = 0; walk; nr ++, walk = walk-&gt;next)
-        if (strcmp(str, walk-&gt;id) == 0)
+        if (strcmp(str, (char *)walk-&gt;id) == 0)
 	    walk-&gt;val.status.mark = val;
 }
 
@@ -410,7 +410,7 @@
     if( !*idl  || number &lt; 0)
         return 0;
     if( number == 0 )
-        return (*idl)-&gt;id;
+        return (char *)(*idl)-&gt;id;
     return str_from_nr_list(&amp;(*idl)-&gt;next, number-1);
 }
 
@@ -421,7 +421,7 @@
     if (*idl == (struct idlist *) 0)
 	return((char *) 0);
     else if (number == (*idl)-&gt;val.status.num)
-	return((*idl)-&gt;id);
+	return((char *)(*idl)-&gt;id);
     else
 	return(str_find(&amp;(*idl)-&gt;next, number));
 }
@@ -441,8 +441,8 @@
 {
     if (*idl == (struct idlist *) 0)
 	return((char *) 0);
-    else if (strcasecmp(id, (*idl)-&gt;id) == 0)
-	return((*idl)-&gt;val.id2 ? (*idl)-&gt;val.id2 : (*idl)-&gt;id);
+    else if (strcasecmp(id, (char *)(*idl)-&gt;id) == 0)
+	return((char *)((*idl)-&gt;val.id2 ? (*idl)-&gt;val.id2 : (*idl)-&gt;id));
     else
 	return(idpair_find(&amp;(*idl)-&gt;next, id));
 }
@@ -611,7 +611,8 @@
 	if (outlevel &gt;= O_DEBUG)
 	    report(stdout, GT_(&quot;Deleting fetchids file.\n&quot;));
 	if (unlink(idfile))
-	    report(stderr, GT_(&quot;Error deleting %s: %s\n&quot;), strerror(errno));
+	    report(stderr, GT_(&quot;Error deleting %s: %s\n&quot;), idfile,
+		   strerror(errno));
     } else {
 	char *newnam = xmalloc(strlen(idfile) + 2);
 	strcpy(newnam, idfile);
@@ -629,7 +630,7 @@
 			    ctl-&gt;remotename, ctl-&gt;server.queryname, (char *)idp-&gt;id);
 	    }
 	    for (idp = scratchlist; idp; idp = idp-&gt;next)
-		fputs(idp-&gt;id, tmpfp);
+		fputs((char *)idp-&gt;id, tmpfp);
 	    fflush(tmpfp);
 	    errflg = ferror(tmpfp);
 	    fclose(tmpfp);
diff -ur fetchmail-6.2.6.alpha1.warn/unmime.c fetchmail-6.2.6.alpha1/unmime.c
--- fetchmail-6.2.6.alpha1.warn/unmime.c	2005-02-27 21:19:36.000000000 +0100
+++ fetchmail-6.2.6.alpha1/unmime.c	2005-07-03 00:38:30.000000000 +0200
@@ -80,7 +80,7 @@
   int  i;
 
   /* Speed up in case this is not a MIME-encoded header */
-  p = strstr(hdr, MIMEHDR_INIT);
+  p = (unsigned char *)strstr((char *)hdr, MIMEHDR_INIT);
   if (p == NULL)
     return;   /* No MIME header */
 
@@ -92,13 +92,13 @@
   for (p_out = p_in = hdr; (*p_in); ) {
     switch (state) {
     case S_COPY_PLAIN:
-      p = strstr(p_in, MIMEHDR_INIT);
+      p = (unsigned char *)strstr((char *)p_in, MIMEHDR_INIT);
       if (p == NULL) {
 	/* 
 	 * No more coded data in buffer, 
          * just move remainder into place. 
 	 */
-        i = strlen(p_in);   /* How much left */
+        i = strlen((char *)p_in);   /* How much left */
 	memmove(p_out, p_in, i);
 	p_in += i; p_out += i;
       }
@@ -117,7 +117,7 @@
 
     case S_SKIP_MIMEINIT:
       /* Mime type definition: &quot;charset?encoding?&quot; */
-      p = strchr(p_in, '?');
+      p = (unsigned char *)strchr((char *)p_in, '?');
       if (p != NULL) {
 	/* p_in .. (p-1) holds the charset */
 
@@ -135,8 +135,8 @@
       break;
 
     case S_COPY_MIME:
-      p = strstr(p_in, MIMEHDR_END);  /* Find end of coded data */
-      if (p == NULL) p = p_in + strlen(p_in);
+      p = (unsigned char *)strstr((char *)p_in, MIMEHDR_END);  /* Find end of coded data */
+      if (p == NULL) p = p_in + strlen((char *)p_in);
       for (; (p_in &lt; p); ) {
 	/* Decode all encoded data */
 	if (enc == 'q') {
@@ -171,7 +171,7 @@
 	  int decoded_count;
 
 	  delimsave = *p; *p = '\r';
-	  decoded_count = from64tobits(p_out, p_in, 0);
+	  decoded_count = from64tobits((char *)p_out, (char *)p_in, 0);
 	  *p = delimsave;
 	  if (decoded_count &gt; 0) 
 	    p_out += decoded_count;            
@@ -193,7 +193,7 @@
        * new MIMEHDR_INIT delimiter must be discarded.
        * See if that is the case 
        */
-      p = strstr(p_in, MIMEHDR_INIT);
+      p = (unsigned char *)strstr((char *)p_in, MIMEHDR_INIT);
       state = S_COPY_PLAIN;
       if (p != NULL) {
 	/*
@@ -397,16 +397,16 @@
   XferEnc = XferEncOfs = CntType = MimeVer = NULL;
 
   do {
-    if (strncasecmp(&quot;Content-Transfer-Encoding:&quot;, NxtHdr, 26) == 0) {
+    if (strncasecmp(&quot;Content-Transfer-Encoding:&quot;, (char *)NxtHdr, 26) == 0) {
       XferEncOfs = NxtHdr;
       p = nxtaddr(NxtHdr);
       if (p != NULL) {
-	xalloca(XferEnc, char *, strlen(p) + 1);
-	strcpy(XferEnc, p);
+	xalloca(XferEnc, unsigned char *, strlen((char *)p) + 1);
+	strcpy((char *)XferEnc, (char *)p);
 	HdrsFound++;
       }
     }
-    else if (strncasecmp(&quot;Content-Type:&quot;, NxtHdr, 13) == 0) {
+    else if (strncasecmp(&quot;Content-Type:&quot;, (char *)NxtHdr, 13) == 0) {
       /*
        * This one is difficult. We cannot use the standard
        * nxtaddr() routine, since the boundary-delimiter is
@@ -428,46 +428,46 @@
        */
       p = NxtHdr-1;
       do {
-        p=strchr((p+1),'\n'); 
+        p=(unsigned char *)strchr((char *)(p+1),'\n'); 
       } while ( (p != NULL) &amp;&amp; ((*(p+1) == '\t') || (*(p+1) == ' ')) );
-      if (p == NULL) p = NxtHdr + strlen(NxtHdr);
+      if (p == NULL) p = NxtHdr + strlen((char *)NxtHdr);
 
-      xalloca(CntType, char *, p-NxtHdr+2);
-      strncpy(CntType, NxtHdr, (p-NxtHdr));
+      xalloca(CntType, unsigned char *, p-NxtHdr+2);
+      strncpy((char *)CntType, (char *)NxtHdr, (p-NxtHdr));
       *(CntType+(p-NxtHdr)) = '\0';
       HdrsFound++;
     }
-    else if (strncasecmp(&quot;MIME-Version:&quot;, NxtHdr, 13) == 0) {
+    else if (strncasecmp(&quot;MIME-Version:&quot;, (char *)NxtHdr, 13) == 0) {
       p = nxtaddr(NxtHdr);
       if (p != NULL) {
-	xalloca(MimeVer, char *, strlen(p) + 1);
-	strcpy(MimeVer, p);
+	xalloca(MimeVer, unsigned char *, strlen((char *)p) + 1);
+	strcpy((char *)MimeVer, (char *)p);
 	HdrsFound++;
       }
     }
 
-    NxtHdr = (strchr(NxtHdr, '\n'));
+    NxtHdr = (unsigned char *)strchr((char *)NxtHdr, '\n');
     if (NxtHdr != NULL) NxtHdr++;
   } while ((NxtHdr != NULL) &amp;&amp; (*NxtHdr) &amp;&amp; (HdrsFound != 3));
 
 
   /* Done looking through the headers, now check what they say */
-  if ((MimeVer != NULL) &amp;&amp; (strcmp(MimeVer, &quot;1.0&quot;) == 0)) {
+  if ((MimeVer != NULL) &amp;&amp; (strcmp((char *)MimeVer, &quot;1.0&quot;) == 0)) {
 
-    CurrTypeNeedsDecode = CheckContentType(CntType);
+    CurrTypeNeedsDecode = CheckContentType((char *)CntType);
 
     /* Check Content-Type to see if this is a multipart message */
     if ( (CntType != NULL) &amp;&amp;
-         ((strncasecmp(CntType, &quot;multipart/mixed&quot;, 16) == 0) ||
-	  (strncasecmp(CntType, &quot;message/&quot;, 8) == 0)) ) {
+         ((strncasecmp((char *)CntType, &quot;multipart/mixed&quot;, 16) == 0) ||
+	  (strncasecmp((char *)CntType, &quot;message/&quot;, 8) == 0)) ) {
 
-      char *p1 = GetBoundary(CntType);
+      char *p1 = GetBoundary((char *)CntType);
 
       if (p1 != NULL) {
 	/* The actual delimiter is &quot;--&quot; followed by 
 	   the boundary string */
-	strcpy(MultipartDelimiter, &quot;--&quot;);
-	strncat(MultipartDelimiter, p1, MAX_DELIM_LEN);
+	strcpy((char *)MultipartDelimiter, &quot;--&quot;);
+	strncat((char *)MultipartDelimiter, p1, MAX_DELIM_LEN);
 	MultipartDelimiter[sizeof(MultipartDelimiter)-1] = '\0';
 	BodyType = (MSG_IS_8BIT | MSG_NEEDS_DECODE);
       }
@@ -478,18 +478,18 @@
      * ONLY for non-multipart messages (BodyType == 0).
      */
     if ((XferEnc != NULL) &amp;&amp; (BodyType == 0)) {
-      if (strcasecmp(XferEnc, &quot;quoted-printable&quot;) == 0) {
+      if (strcasecmp((char *)XferEnc, &quot;quoted-printable&quot;) == 0) {
 	CurrEncodingIsQP = 1;
 	BodyType = (MSG_IS_8BIT | MSG_NEEDS_DECODE);
 	if (WantDecode &amp;&amp; CurrTypeNeedsDecode) {
            SetEncoding8bit(XferEncOfs);
         }
       }
-      else if (strcasecmp(XferEnc, &quot;7bit&quot;) == 0) {
+      else if (strcasecmp((char *)XferEnc, &quot;7bit&quot;) == 0) {
 	CurrEncodingIsQP = 0;
 	BodyType = (MSG_IS_7BIT);
       }
-      else if (strcasecmp(XferEnc, &quot;8bit&quot;) == 0) {
+      else if (strcasecmp((char *)XferEnc, &quot;8bit&quot;) == 0) {
 	CurrEncodingIsQP = 0;
 	BodyType = (MSG_IS_8BIT);
       }
@@ -517,22 +517,22 @@
    * Special case: line consists of a single =2E and messages are 
    * dot-terminated.  Line has to be dot-stuffed after decoding.
    */
-  if (delimited &amp;&amp; !issoftline &amp;&amp; buf[0]=='=' &amp;&amp; !strncmp(*bufp, &quot;=2E\r\n&quot;, 5))
+  if (delimited &amp;&amp; !issoftline &amp;&amp; buf[0]=='=' &amp;&amp; !strncmp((char *)*bufp, &quot;=2E\r\n&quot;, 5))
   {
-      strcpy(buf, &quot;..\r\n&quot;);
+      strcpy((char *)buf, &quot;..\r\n&quot;);
       *bufp += 5;
       return(FALSE);
   }
 
   p_in = buf;
-  if (delimited &amp;&amp; issoftline &amp;&amp; (strncmp(buf, &quot;..&quot;, 2) == 0))
+  if (delimited &amp;&amp; issoftline &amp;&amp; (strncmp((char *)buf, &quot;..&quot;, 2) == 0))
     p_in++;
 
   for (p_out = buf; (*p_in); ) {
-    p = strchr(p_in, '=');
+    p = (unsigned char *)strchr((char *)p_in, '=');
     if (p == NULL) {
       /* No more QP data, just move remainder into place */
-      n = strlen(p_in);
+      n = strlen((char *)p_in);
       memmove(p_out, p_in, n);
       p_in += n; p_out += n;
     }
@@ -596,13 +596,13 @@
   switch (BodyState) {
   case S_BODY_HDR:
     UnMimeHeader(buf);   /* Headers in body-parts can be encoded, too! */
-    if ((*buf == '\0') || (*buf == '\n') || (strcmp(buf, &quot;\r\n&quot;) == 0)) {
+    if ((*buf == '\0') || (*buf == '\n') || (strcmp((char *)buf, &quot;\r\n&quot;) == 0)) {
       BodyState = S_BODY_DATA;
     } 
-    else if (strncasecmp(&quot;Content-Transfer-Encoding:&quot;, buf, 26) == 0) {
+    else if (strncasecmp(&quot;Content-Transfer-Encoding:&quot;, (char *)buf, 26) == 0) {
       char *XferEnc;
 
-      XferEnc = nxtaddr(buf);
+      XferEnc = (char *)nxtaddr(buf);
       if ((XferEnc != NULL) &amp;&amp; (strcasecmp(XferEnc, &quot;quoted-printable&quot;) == 0)) {
 	CurrEncodingIsQP = 1;
 
@@ -617,16 +617,16 @@
 	    SetEncoding8bit(buf);
       }
     }
-    else if (strncasecmp(&quot;Content-Type:&quot;, buf, 13) == 0) {
-      CurrTypeNeedsDecode = CheckContentType(nxtaddr(buf));
+    else if (strncasecmp(&quot;Content-Type:&quot;, (char *)buf, 13) == 0) {
+      CurrTypeNeedsDecode = CheckContentType((char *)nxtaddr(buf));
     }
 
-    *bufp = (buf + strlen(buf));
+    *bufp = (buf + strlen((char *)buf));
     break;
 
   case S_BODY_DATA:
     if ((*MultipartDelimiter) &amp;&amp; 
-	(strncmp(buf, MultipartDelimiter, strlen(MultipartDelimiter)) == 0)) {
+	(strncmp((char *)buf, (char *)MultipartDelimiter, strlen((char *)MultipartDelimiter)) == 0)) {
       BodyState = S_BODY_HDR;
       CurrEncodingIsQP = CurrTypeNeedsDecode = 0;
     }
@@ -634,7 +634,7 @@
     if (CurrEncodingIsQP &amp;&amp; CurrTypeNeedsDecode) 
       ret = DoOneQPLine(bufp, delimited, softline);
     else
-     *bufp = (buf + strlen(buf));
+      *bufp = (buf + strlen((char *)buf));
     break;
   }
 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000308.html">[fetchmail-devel] i18n fixes
</A></li>
	<LI>Next message: <A HREF="000305.html">[fetchmail-devel] Cleanups
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#304">[ date ]</a>
              <a href="thread.html#304">[ thread ]</a>
              <a href="subject.html#304">[ subject ]</a>
              <a href="author.html#304">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/fetchmail-devel">More information about the fetchmail-devel
mailing list</a><br>
</body></html>
